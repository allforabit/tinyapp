{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Tinyapp","google":"UA-37357690-1","tagline":"A minimal, modular, client-side application framework.","body":"# Tinyapp - Simple module management.\r\n\r\nTinyapp is a simple event-driven client-side JavaScript application architecture and module management framework that serves the following needs:\r\n\r\n* Sandbox / Namespacing\r\n* Environment\r\n* Lifecycle Hooks\r\n* Deferreds / Promises\r\n\r\nTinyapp is based on Applitude: Simple module management.  **View the slideshow: [\"Introducing Applitude: Simple Module Management\"](https://docs.google.com/presentation/embed?id=1BQ6s5EzLqenWZX1RCUIgVlJViKzjZAvvxN4UVkQzspo&start=false&loop=false&delayms=10000)**\r\n\r\n**Status** - Developer preview (stick to tested, documented features for best results). [![Build Status](https://secure.travis-ci.org/dilvie/tinyapp.png)](http://travis-ci.org/dilvie/tinyapp)\r\n\r\nThe guiding philosophy of Tinyapp is “Less is more.” Tinyapp lays the wiring and then gets out of the way of your modules. Hence the subtitle, “Simple Module Management.”\r\n\r\nTinyapp was created to illustrate how to implement a client-side JavaScript application architecture for the upcoming book \"Programming JavaScript Applications\" (O'Reilly).\r\n\r\n## Who's Using Tinyapp?\r\n\r\n* [Tout](http://tout.com/)\r\n\r\n\r\n## Getting started\r\n\r\nTinyapp uses `npm` for dependency management and CommonJS to use the dependencies in your modules.\r\n\r\nIf you don't have node installed, you can download it from `http://nodejs.org/download/`.\r\n\r\nIn your project's `package.json` file, make sure to include tinyapp:\r\n\r\n    dependencies: {\r\n      \"tinyapp\": \"*\" // use latest version\r\n    }\r\n\r\nYou'll also need something like browserify and grunt to build your app:\r\n\r\n  \"devDependencies\": {\r\n    \"grunt-browserify\": \"~0.1.x\",\r\n    \"grunt\": \"~0.3.x\",\r\n    \"traverse\": \"~0.6.x\",\r\n    \"browserify\": \"~1.15.x\"\r\n  }\r\n\r\n\r\n### Inside your main file (often, `app.js`):\r\n\r\n    var app = require('tinyapp');\r\n\r\n    app.init({\r\n      // Pass your app configuration in here.\r\n      environment: myEnvironment,\r\n\r\n      // A promise that must be resolved before the app\r\n      // renders.\r\n      beforeRender: myPromise\r\n    });\r\n\r\n\r\n### Create your first tinyapp module\r\n\r\n\r\nCreate a namespace:\r\n\r\n    var namespace = 'hello';\r\n\r\nInclude tinyapp:\r\n\r\n    var namespace = 'hello',\r\n      app = require('tinyapp');\r\n\r\n    // use app as desired\r\n\r\n\r\nProvide an API:\r\n\r\n    var namespace = 'hello',\r\n      app = require('tinyapp'),\r\n\r\n      hello: function hello() {\r\n        return 'hello, world';\r\n      },\r\n\r\n      api = {\r\n        hello: hello\r\n      };\r\n\r\n\r\nExport your module:\r\n\r\n    var namespace = 'hello',\r\n      app = require('tinyapp'),\r\n\r\n      hello: function hello() {\r\n        return 'hello, world';\r\n      },\r\n\r\n      api = {\r\n        hello: hello\r\n      };\r\n\r\n    module.exports = api;\r\n\r\n\r\nExporting your module makes it available to `require()` in other modules.\r\n\r\n\r\nIt's nice to declare a namespace, because you'll be using a lot of events, and declaring a namespace lets you do things like this:\r\n\r\n    var eventData = {\r\n      namespace: namespace,\r\n      detail: 'my custom event data'\r\n    };\r\n    app.trigger('something_happened' eventData);\r\n\r\nThat makes refactoring really easy. You can move code from one module to another without breaking it, or change a module's namespace without impacting any of the module code.\r\n\r\nDeclaring your API explicitly makes it immediately clear which parts of your module constitute the exposed interface.\r\n\r\n      api = {\r\n        hello: hello\r\n      };\r\n\r\nIn this case, it's just `hello`, but most interfaces will be more complicated.\r\n\r\n\r\n### Loading and Rendering\r\n\r\nModule initialization is broken into two phases:\r\n\r\n#### Load\r\n\r\nThe first is the load phase. Tinyapp exposes an `app.loadReady()` method that takes a callback function that you define in your module. The intention of the `app.loadReady()` method is to allow you to begin setting up your data models, including firing any asynchronous Ajax load methods that need to happen before you can render your module to the document.\r\n\r\n\r\n#### Render\r\n\r\nSimilarly, the `app.renderReady()` callback is called after:\r\n\r\n1. all `.beforeRender` callbacks have fired, and\r\n1. the DOM is ready to be manipulated\r\n\r\nThis allows you to defer render until it's safe to do so. For example, say you want to render Skrillex tour dates from BandsInTown:\r\n\r\n    var namespace = 'skrillexInfo',\r\n      app = require('tinyapp'),\r\n      data,\r\n      whenLoaded,\r\n  \r\n      load = function load(url) {\r\n        var url = url || \r\n          'http://api.bandsintown.com/artists/Skrillex.' +\r\n          'json?api_version=2.0&app_id=YOUR_APP_ID';\r\n\r\n        whenLoaded = app.get(url);\r\n\r\n        whenLoaded.done(function (response) {\r\n          data = response;\r\n        });\r\n\r\n        return whenLoaded.promise();\r\n      },\r\n\r\n      render = function render(data) {\r\n\r\n      }\r\n\r\n      // Expose API for flexibility and unit testing.\r\n      api = {\r\n        load: load,\r\n        render: render\r\n      };\r\n\r\n    // Register load and render callbacks.\r\n    app.loadReady(load);\r\n    app.renderReady(render);\r\n\r\n    module.exports = api;\r\n\r\n\r\nTip: Try not to do anything blocking in your `app.loadReady()` callback. For example, you might want to asynchronously fetch the data that you need to complete your page render, but if you're loading a fairly large collection and you need to iterate over the collection and do some data processing, save the data processing step for `app.renderReady()`, when you're not blocking the page load process.\r\n\r\n*You can't safely manipulate the DOM in your `.loadReady()` callback.*\r\n\r\n\r\n## Environment\r\n\r\nEnvironment is made up of things like image hosting URLs which might vary from one host or CDN to another. Generally server side environments will also contain passwords, secrets, or tokens for communicating with third party APIs. Since the client-side environment is not secure, you should not pass those secrets through to the client layer.\r\n\r\nEnvironment variables should be passed into your application from your environment configuration, and not hard-coded. Your application should be portable to new hardware or hosts without any changes to your codebase.\r\n\r\nIt might be tempting to pass a single environment string through and put logic in your code to determine URLs and so on, but that would make your application less portable.\r\n\r\nAs a general rule of thumb, your app should be ready to open-source at any time, even if you never intend to do it. That mode of thought will help establish the proper separation of environment configuration and secrets from application code.\r\n\r\nFor more on application configuration, see [\"The Twelve-Factor App\"](http://www.12factor.net/config)\r\n\r\n\r\n## Options\r\n\r\n### `beforeRender`\r\n\r\n`beforeRender` is a list of application-level promises which all must finish before the render process begins. For example, many apps will need translations to load before modules are allowed to render. By adding an i18n (internationalization) promise to the application's `beforeRender` queue, you can postpone render until the translations are loaded. Using `beforeRender` can prevent tricky race condition bugs from cropping up, and provide a neat solution if you need a guaranteed way to handle tasks before the modules render.\r\n\r\nYou can resolve `beforeRender` promises by listening for an expected event to fire. Inside `app.js`:\r\n\r\n    var namespace = 'app',\r\n      whenI18nLoaded = app.deferred();\r\n\r\n    app.on('translations_loaded.' + namespace, function () {\r\n      whenI18nLoaded.resolve();\r\n    });\r\n\r\n    app.init({\r\n      beforeRender: [whenI18nLoaded.promise()],\r\n    });\r\n\r\n\r\nLater:\r\n\r\n    whenTranslationsLoaded.done(function () {\r\n      app.trigger('translations_loaded.' + namespace);\r\n    });\r\n\r\n\r\n## Tinyapp Responsibilities\r\n\r\n### Events\r\n\r\nModules should know as little as possible about each other. To that end, modules should communicate through events. There is an app level event bus supplied by the tinyapp sandbox. You can use `app.on()` to subscribe to events, `app.off()` to unsubscribe, and `app.trigger()` to publish.\r\n\r\n    app.on('a.*', function (data) { \r\n        console.log(data);\r\n    });\r\n    \r\n    // later\r\n    app.trigger('a.b', 'hello, world'); // logs 'hello, world'\r\n\r\nBe specific about the events you report, and namespace your events. For example:\r\n\r\n    var namespace = 'videoPlayer.view',\r\n\r\n      // Capture click events and relay them to the app\r\n      // event bus.\r\n      bindEvents = function bindEvents() {\r\n        // Delegate to the view's parent element.\r\n        app.$('#playerview').on('click.' + namespace,\r\n            '.play-button', function (event) {\r\n          event.namespace = 'videoPlayer.view'\r\n          app.trigger('click', event);\r\n        });\r\n      },\r\n\r\n      // Expose the bindEvents method for testing.\r\n      api = {\r\n          bindEvents: bindEvents\r\n      };\r\n\r\n    // Let Tinyapp call bindEvents when the DOM is ready\r\n    // to attach events to.\r\n    app.renderReady(bindEvents);\r\n    module.exports = api;\r\n\r\n\r\n## Sandbox\r\n\r\nAccess libraries and utilities through a canonical interface (a facade), rather than calling library code directly. Doing so allows you to modify the implementation, or swap out the library completely with transparency to the application code.\r\n\r\n\r\n### Included Sandbox API\r\n\r\n* `.init()` - Initialize the app.\r\n* `.register()` - Register your module with the app sandbox.\r\n* `.loadReady()` - Pass in callbacks to run at load time.\r\n* `.renderReady()` - Pass in callbacks to run at render time.\r\n* `.events` - Node Event Emitter compatible event emitter.\r\n* `.on()` - Delegates to `events.on()`.\r\n* `.off()` - Delegates to `events.off()`.\r\n* `.trigger()` - Delegates to `events.emit()`.\r\n* `.$()` - A selector engine for dom utilities.\r\n* `.get()` - jQuery compatible Ajax `.get()`.\r\n* `.ajax()` - jQuery compatible `.ajax()`.\r\n* `.when` - jQuery compatible .when().\r\n* `.deferred()` - jQuery compatible deferred API.\r\n* `.resolved` - A resolved promise.\r\n* `.rejected` - A rejected promise.\r\n\r\n\r\n## Registration\r\n\r\nModules that you wish to add to the sandbox (to be used by many other modules) need to be registered. Tinyapp supports deep namespaces. For example:\r\n\r\n    var namespace = 'i18n.date',\r\n      api;\r\n\r\n    // Later...\r\n    app.register(namespace, api);\r\n    module.exports = api;\r\n\r\nThis example will create an `i18n` object if it doesn't already exist, and attach the `api` object at `app.i18n.date`.\r\n\r\n## Deferred utilities\r\n\r\nTinyapp relies on promises and deferreds from the jQuery library. \r\nTinyapp exposes a few Deferred utilities, including:\r\n\r\n* `.resolved` - A resolved promise\r\n* `.rejected` - A rejected promise\r\n* `.when()` - A utility that allows you to run callbacks only after all promises passed to it are resolved.\r\n\r\nThese utilities can be helpful for coordinating asynchronous events in your application.\r\n\r\n"}